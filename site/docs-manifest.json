[
  {
    "fileName": "getting-started.md",
    "id": "getting-started",
    "route": "/documentation/",
    "sections": [
      {
        "raw": "# ",
        "level": 1,
        "name": "",
        "breadcrumbs": [
          ""
        ],
        "content": "Zero-runtimeStylesheets-in-TypeScript.  Write your styles in TypeScript (or JavaScript) with locally scoped class names and CSS Variables, then generate static CSS files at build time.  Basically, it’s “CSS Modules-in-TypeScript” but with scoped CSS Variables + heaps more.  > 🚧 &nbsp; Please note, this is an alpha release.  🔥 &nbsp; All styles generated at build time — just like Sass, Less, etc.  ✨ &nbsp; Minimal abstraction over standard CSS.  🦄 &nbsp; Works with any front-end framework — or even without one.  🌳 &nbsp; Locally scoped class names — just like CSS Modules.  🚀 &nbsp; Locally scoped CSS Variables, @keyframes and @font-face rules.  🎨 &nbsp; High-level theme system with support for simultaneous themes. No globals!  🛠 &nbsp; Utils for generating variable-based calc expressions.  💪 &nbsp; Type-safe styles via CSSType.  🏃‍♂️ &nbsp; Optional runtime version for development and testing.  🙈 &nbsp; Optional API for dynamic runtime theming.  > 🖥 &nbsp; Try it out for yourself in CodeSandbox.  Write your styles in .css.ts files.    ---  Want to work at a higher level while maximising style re-use? Check out 🍨 Sprinkles, our official zero-runtime atomic CSS framework, built on top of vanilla-extract.  ---",
        "page": "Getting Started",
        "hash": ""
      }
    ]
  },
  {
    "fileName": "styling-api.md",
    "id": "styling-api",
    "route": "/documentation/styling-api/",
    "sections": [
      {
        "raw": "# Styling API",
        "level": 1,
        "name": "Styling API",
        "breadcrumbs": [
          "Styling API"
        ],
        "content": "style  Creates styles attached to a locally scoped class name.    > 💡 To improve maintainability, each style block can only target a single element. To enforce this, all selectors must target the & character which is a reference to the current element. For example, '&:hover:not(:active)' is considered valid, while '& > a' and ` & ${childClass}]  are not. > > If you want to target another scoped class then it should be defined within the style block of that class instead. For example,  [& ${childClass}]  is invalid since it targets ${childClass}, so it should instead be defined in the style block for childClass. > > If you want to globally target child nodes within the current element (e.g. '& > a'), you should use [globalStyle` instead.",
        "page": "Styling API",
        "hash": "styling-api"
      },
      {
        "raw": "## style",
        "level": 2,
        "name": "style",
        "breadcrumbs": [
          "Styling API",
          "style"
        ],
        "content": "style",
        "page": "Styling API",
        "hash": "style"
      },
      {
        "raw": "## styleVariants",
        "level": 2,
        "name": "styleVariants",
        "breadcrumbs": [
          "Styling API",
          "styleVariants"
        ],
        "content": "  Creates a collection of named style variants.",
        "page": "Styling API",
        "hash": "stylevariants"
      },
      {
        "raw": "## globalStyle",
        "level": 2,
        "name": "globalStyle",
        "breadcrumbs": [
          "Styling API",
          "globalStyle"
        ],
        "content": "  Creates styles attached to a global selector.    > 💡 All theme variants must provide a value for every variable or it’s a type error.",
        "page": "Styling API",
        "hash": "globalstyle"
      },
      {
        "raw": "## createTheme",
        "level": 2,
        "name": "createTheme",
        "breadcrumbs": [
          "Styling API",
          "createTheme"
        ],
        "content": "createGlobalTheme  Creates a theme attached to a global selector, but with locally scoped variable names.    > 💡 All theme variants must provide a value for every variable or it’s a type error.  ## createTheme",
        "page": "Styling API",
        "hash": "createtheme"
      },
      {
        "raw": "## createGlobalTheme",
        "level": 2,
        "name": "createGlobalTheme",
        "breadcrumbs": [
          "Styling API",
          "createGlobalTheme"
        ],
        "content": "  Creates a theme attached to a global selector, but with locally scoped variable names.    > 💡 All theme variants must provide a value for every variable or it’s a type error.",
        "page": "Styling API",
        "hash": "createglobaltheme"
      },
      {
        "raw": "## createThemeContract",
        "level": 2,
        "name": "createThemeContract",
        "breadcrumbs": [
          "Styling API",
          "createThemeContract"
        ],
        "content": "  Creates a contract for themes to implement.  Ensure this function is called within a .css.ts context, otherwise variable names will be mismatched between themes.  > 💡 This is useful if you want to split your themes into different bundles. In this case, your themes would be defined in separate files, but we'll keep this example simple.",
        "page": "Styling API",
        "hash": "createthemecontract"
      },
      {
        "raw": "## assignVars",
        "level": 2,
        "name": "assignVars",
        "breadcrumbs": [
          "Styling API",
          "assignVars"
        ],
        "content": "  Assigns a collection of CSS Variables anywhere within a style block.  > 💡 This is useful for creating responsive themes since it can be used within @media blocks.    > 💡 All variables passed into this function must be assigned or it’s a type error.",
        "page": "Styling API",
        "hash": "assignvars"
      },
      {
        "raw": "## createVar",
        "level": 2,
        "name": "createVar",
        "breadcrumbs": [
          "Styling API",
          "createVar"
        ],
        "content": "  Creates a single CSS Variable.",
        "page": "Styling API",
        "hash": "createvar"
      },
      {
        "raw": "## fallbackVar",
        "level": 2,
        "name": "fallbackVar",
        "breadcrumbs": [
          "Styling API",
          "fallbackVar"
        ],
        "content": "  Provides fallback values when consuming variables.",
        "page": "Styling API",
        "hash": "fallbackvar"
      },
      {
        "raw": "## fontFace",
        "level": 2,
        "name": "fontFace",
        "breadcrumbs": [
          "Styling API",
          "fontFace"
        ],
        "content": "  Creates a custom font attached to a locally scoped font name.",
        "page": "Styling API",
        "hash": "fontface"
      },
      {
        "raw": "## globalFontFace",
        "level": 2,
        "name": "globalFontFace",
        "breadcrumbs": [
          "Styling API",
          "globalFontFace"
        ],
        "content": "  Creates a globally scoped custom font.",
        "page": "Styling API",
        "hash": "globalfontface"
      },
      {
        "raw": "## keyframes",
        "level": 2,
        "name": "keyframes",
        "breadcrumbs": [
          "Styling API",
          "keyframes"
        ],
        "content": "  Creates a locally scoped set of keyframes.",
        "page": "Styling API",
        "hash": "keyframes"
      },
      {
        "raw": "## globalKeyframes",
        "level": 2,
        "name": "globalKeyframes",
        "breadcrumbs": [
          "Styling API",
          "globalKeyframes"
        ],
        "content": "  Creates a globally scoped set of keyframes.",
        "page": "Styling API",
        "hash": "globalkeyframes"
      },
      {
        "raw": "## composeStyles",
        "level": 2,
        "name": "composeStyles",
        "breadcrumbs": [
          "Styling API",
          "composeStyles"
        ],
        "content": "  Combines mutliple styles into a single class string, while also deduplicating and removing unnecessary spaces.    > 💡 Styles can also be provided in shallow and deeply nested arrays. Think of it as a static version of classnames.",
        "page": "Styling API",
        "hash": "composestyles"
      }
    ]
  },
  {
    "fileName": "utility-functions.md",
    "id": "utility-functions",
    "route": "/documentation/utility-functions/",
    "sections": [
      {
        "raw": "# Utility Functions",
        "level": 1,
        "name": "Utility Functions",
        "breadcrumbs": [
          "Utility Functions"
        ],
        "content": "  We also provide a standalone package of optional utility functions to make it easier to work with CSS in TypeScript.  > 💡 This package can be used with any CSS-in-JS library.",
        "page": "Utility Functions",
        "hash": "utility-functions"
      },
      {
        "raw": "## calc",
        "level": 2,
        "name": "calc",
        "breadcrumbs": [
          "Utility Functions",
          "calc"
        ],
        "content": "  Streamlines the creation of CSS calc expressions.",
        "page": "Utility Functions",
        "hash": "calc"
      }
    ]
  },
  {
    "fileName": "dynamic-api.md",
    "id": "dynamic-api",
    "route": "/documentation/dynamic-api/",
    "sections": [
      {
        "raw": "# Dynamic API",
        "level": 1,
        "name": "Dynamic API",
        "breadcrumbs": [
          "Dynamic API"
        ],
        "content": "  We also provide a lightweight standalone package to support dynamic runtime theming.",
        "page": "Dynamic API",
        "hash": "dynamic-api"
      },
      {
        "raw": "## createInlineTheme",
        "level": 2,
        "name": "createInlineTheme",
        "breadcrumbs": [
          "Dynamic API",
          "createInlineTheme"
        ],
        "content": "  Implements a theme contract at runtime as an inline style object.",
        "page": "Dynamic API",
        "hash": "createinlinetheme"
      },
      {
        "raw": "## setElementTheme",
        "level": 2,
        "name": "setElementTheme",
        "breadcrumbs": [
          "Dynamic API",
          "setElementTheme"
        ],
        "content": "  Implements a theme contract on an element.    > 💡 All variables passed into this function must be assigned or it’s a type error.",
        "page": "Dynamic API",
        "hash": "setelementtheme"
      },
      {
        "raw": "## setElementVar",
        "level": 2,
        "name": "setElementVar",
        "breadcrumbs": [
          "Dynamic API",
          "setElementVar"
        ],
        "content": "  Sets a single var on an element.",
        "page": "Dynamic API",
        "hash": "setelementvar"
      }
    ]
  },
  {
    "fileName": "setup.md",
    "id": "setup",
    "route": "/documentation/setup/",
    "sections": [
      {
        "raw": "# Setup",
        "level": 1,
        "name": "Setup",
        "breadcrumbs": [
          "Setup"
        ],
        "content": "  There are currently a few integrations to choose from.",
        "page": "Setup",
        "hash": "setup"
      },
      {
        "raw": "## Webpack",
        "level": 2,
        "name": "Webpack",
        "breadcrumbs": [
          "Setup",
          "Webpack"
        ],
        "content": "  Install the dependencies.",
        "page": "Setup",
        "hash": "webpack"
      },
      {
        "raw": "## esbuild",
        "level": 2,
        "name": "esbuild",
        "breadcrumbs": [
          "Setup",
          "esbuild"
        ],
        "content": "  Install the dependencies.   > Please note: There are currently no automatic readable class names during development. However, you can still manually provide a debug ID as the last argument to functions that generate scoped styles, e.g. export const className = style({ ... }, 'className');",
        "page": "Setup",
        "hash": "esbuild"
      },
      {
        "raw": "## Vite",
        "level": 2,
        "name": "Vite",
        "breadcrumbs": [
          "Setup",
          "Vite"
        ],
        "content": "Warning: Currently the Vite plugin doesn't rebuild files when dependent files change, e.g. updating theme.css.ts should rebuild styles.css.ts which imports theme.css.ts. This is a limitation in the Vite Plugin API that will hopefully be resolved soon. You can track the Vite issue here: https://github.com/vitejs/vite/issues/3216  1. Install the dependencies.    > Please note: There are currently no automatic readable class names during development. However, you can still manually provide a debug ID as the last argument to functions that generate scoped styles, e.g. export const className = style({ ... }, 'className');",
        "page": "Setup",
        "hash": "vite"
      },
      {
        "raw": "## Gatsby",
        "level": 2,
        "name": "Gatsby",
        "breadcrumbs": [
          "Setup",
          "Gatsby"
        ],
        "content": "  To add to your Gatsby site, use the gatsby-plugin-vanilla-extract plugin.",
        "page": "Setup",
        "hash": "gatsby"
      }
    ]
  }
]